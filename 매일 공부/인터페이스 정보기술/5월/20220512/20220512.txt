
 정리.



 # 빌더 패턴.

필요성.
● 유연성을 확보할 수 있음.
● 가독성을 높일 수 있음.
● 불변성을 확보할 수 있음.
● 필요한 데이터만 설정할 수 있음.

@Builder.
● builderMethodName 속성에 작성한 이름으로 Builder 메소드를 생성해준다.
● 모든 속성이 들어간 생성자를 자동으로 생성해준다.



 # 전략 패턴.

개념.
객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 캡슐화 하는 인터페이스를 정의.
객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법.

장점.
코드 변경 없이 새로운 전략을 추가 할 수 있다.
	● if-else 분기를 제거할 수 있다.
	● if-else 분기를 제거하면, 단일 책임 원칙을 준수하기 더 수월해진다.
확장에 유리한 코드를 작성할 수 있다.
	● 새롭게 필요한 전략 콘크리트 클래스를 쉽게 만들 수 있다.
	● 개방 폐쇄 원칙을 준수한 코드 작성이 가능하다.
런타임에 전략을 변경시킬 수 있다.

단점.
어플리케이션에 들어가는 모든 전략을 알고 있어야 한다.
	● 클래스로 분리한 각 전략들이 어느 상황에 사용되어야 할 지 알고 있어야 한다.
	● 이 같은 특성이 유지보수를 더 힘들게 할 수도 있다.
전략을 추상화한 인터페이스가 효율적이지 못할 수 있다.
	● 어떤 전략 콘크리트 객체에서는 사용하지 않는 메소드들 역시 전략 인터페이스에 정의해 주어야 한다.



 # 디자인 패턴의 종류.

Creational.
객체 생성 메커니즘에 관련된 패턴으로써, 상황에 알맞은 객체를 생성하기 위해 사용.

Structural.
객체 간의 구조와 관계를 쉽게 인지하도록 설계하기 위해 사용.

Behavioral.
객체 간의 커뮤니케이션 패턴을 정의해 놓음으로써, 커뮤니케이션에 유연성을 증대시켜줌.



 # Exception.

Connection reset by peer.
원인.
	● 원격 서버에서 Connection을 reset 처리.
	● 종료된 커넥션을 재사용하려고 할 때.
	● 브라우저에서 정지버튼을 누르거나, 브라우저를 종료하거나, 다른 화면으로 이동하는 등의 이유.
	● Connection에서 Timeout 발생.
	● 메모리부족.
	● 소켓 고갈 등등.



 # Java.

serialVersionUID를 선언해야 하는 이유.
● JVM은 직렬화 역직렬화를 할 때 클래스에 대한 버전 번호를 부여합니다.
● 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당합니다.

자바 리플렉션.
개념.
	● 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API.
	● C, C++ 같은 언어에서는 볼 수 없는 기능이다.
	● 클래스 런타임 시점에 동적으로 생성하는 자바 API이다.
추가적인 설명.
	● 우리가 코딩을 하면서 직접 사용하는 일은 거의 없다. ( 우리가 작성한 코드의 구체적인 클래스를 모를 일이 없다 )
	● 대부분 프레임워크나 라이브러리 등 사용하는 사람이 어떤 클래스를 만들지 모르는 경우 리플레션을 통해 동적으로 이 문제를 해결.
	● 자바 리플렉션이 가져올 수 없는 정보들 중에 생성자의 인자 정보들이 있다.
	● 기본 생성자로 객체를 생성한 후에 필드값을 초기화한다.
단점.
	● 이미 인스턴스를 만들었음에도 리플렉션을 이용해서 접근하거나 사용할 경우 불필요한 메모리 낭비를 야기한다.
	● 컴파일 타임에 확인되지 않고 런타임 시에만 발생하는 문제들이 생길 수 있다.
	● 접근 지시자를 무시할 수 있다.

JPA에 기본 생성자가 있어야 하는 이유.
● JPA에서는 리플렉션을 사용해서 Entity를 생성하는데, 리플렉션은 생성자의 인자 정보들을 알 수 없으므로 기본 생성자를 사용해야 한다.

서블릿 컨테이너.
개념.
	● 서블릿들을 위한 Container이다.
	● 서블릿들의 생성, 실행, 파괴를 담당한다.
	● 톰캣의 서블릿 컨테이너는 카탈리나이다.
서블릿 생명주기 관리.
	● 서블릿 클래스를 로딩하여 인스턴스화.
	● 초기화 메소드를 호출.
	● 요청이 들어오면 적절한 서블릿 메소드를 호출.
	● 서블릿 소멸 시 가비지 컬렉션을 진행.
멀티쓰레드 지원 및 관리.
	● 서블릿 컨테이너는 요청이 올 때 마다 새로운 자바 쓰레드를 하나 생성.
	● HTTP 서비스 메소드를 실행하고 나면 쓰레드는 자동으로 소멸.
	● 원래는 쓰레드를 관리해야 하지만 서버가 다중 쓰레드를 생성 및 운영해주니 안정성 걱정은 하지 않아도 된다.
선언적인 보완 관리.
	● 서블릿 컨테이너를 사용하면 개발자는 보안에 관련된 내용을 서블릿 또는 자바 클래스에 구현하지 않아도 된다.

톰캣 Tomcat.
개념.
	● 아파치재단에서 제공하는 오픈소스 웹 애플리케이션 서버이다. ( WAS )
	● 서블릿 및 자바 서버 페이지 컨테이너이다.
구성요소.
	● 카탈리나.
		○ 톰캣의 서블릿 컨테이너이다.
		○ 서블릿과 JSP에 대한 선 마이크로시스템즈의 사양을 구현한다.
	● 코요테.
		○ 웹 서버로 HTTP 1.1 프로토콜을 지원하는 톰캣용 커넥터 컴포넌트이다.
		○ 특정 TCP 포트의 서버로 들어오는 연결을 청취하고 톰캣 엔진에 전달하여 요청을 처리.
		○ 코요테 JK는 JK 프로토콜을 사용하여 아파치와 같은 다른 웹 서버에 요청을 전달한다.
	● 재스퍼.
		○ 톰캣의 자바 서버 페이지 엔진이다.
		○ 자바 서버 페이지 파일을 구문 분석하여 서블릿으로 자바 코드로 컴파일한다.
		○ 재스퍼는 런타임에 JSP 파일의 변경 사항을 감지하여 다시 컴파일한다.
설치 요구사항.
	● JDK 버전 1.8 이상을 설치해야 한다.
톰캣 환경변수.
	● 톰캣을 사용하는 애플리케이션은 Catalina_HOME 환경 변수 값을 검사하여 애플리케이션 서버의 위치를 찾는다.
출처.
	● http://wiki.hash.kr/index.php/%ED%86%B0%EC%BA%A3 

템플릿 엔진.
개념.
	● 템플릿 양식과 특정 데이터 모델에 따른 입력 자료를 합성하여 결과 문서를 출력하는 소프트웨어 또는 소프트웨어 컴포넌트.
서버 사이드 템플릿 엔진.
	● 서버에서 DB 혹은 API에서 가져온 데이터를 템플릿에 넣어 HTML 문서를 만들어 클라이언트에 전달해주는 역할.
	● JSP, Thymeleaf, Velocity, Freemarker 등이 있다.
클라이언트 사이드 템플릿 엔진.
	● 데이터를 받아 동적으로 DOM을 그리게 해주는 역할을 한다.
	● Mustache, Squirrelly 등이 있다.
템플릿 엔진을 사용하는 이유.
	● 많은 코드를 줄일 수 있다.
	● 재사용성이 높다.
	● 유지보수에 용이하다.

JVM Java Virtual Machine.
개념.
	● 자바와 운영체제 사이에서 중개자 역할을 수행한다.
	● 자바가 운영체제에 구애 받지 않고 프로그램을 수행할 수 있도록 도와준다.
구성요소.
	● Class Loader.
		○ JVM 내로 클래스 파일을 로더하고, 링크를 통해 배치하는 작업을 수행하는 모듈.
		○ 런타임 시에 동적으로 클래스를 로드한다.
	● Execution Engine.
		○ 클래스 로더를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드들을 명령어 단위로 읽어서 실행.
		○ JIT 컴파일러 방식과 인터프리터 방식을 혼용해서 사용한다.
		○ JIT는 바이트 코드를 어셈블러 같은 네이티브 코드로 바꿈으로써 실행이 빠르지만 변환하는데 비용이 발생.
	● Garbage Collector.
		○ 힙 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후 제거하는 역할.
	● Runtime Data Area.
		○ Method area : 모든 쓰레드가 공유하는 메모리 영역. ( 클래스, 인터페이스, 메소드, 필드, Static 변수 등 )
		○ Heap area : 모든 쓰레드가 공유하며, new 키워드로 생성된 객체와 배열이 생성. ( 메소드 영역에 로드된 클래스만 생성 )
		○ Stack area :  메소드 호출시마다 각각의 스택 공간이 생성된다. 메소드 수행이 끝나면 삭제.
		○ PC Register : 쓰레드가 시작될 때 생성되며, 생성될 때마다 생성되는 공간으로 쓰레드마다 하나씩 존재.
		○ Native Method stack : 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역.
출처.
	● https://steady-coding.tistory.com/305



 # 프런트.

Jquery를 사용하지 않아야 하는 이유.
1. 대부분의 우리가 필요한 기능들에 비해 너무 크기가 비대하다. ( 단순하게 처리가능한 작업에도 래핑이 되어 있다 )
2. 한 가지 기능에만 집중적으로 개발된 라이브러리들이 많이 있다. ( 대체 가능한 라이브러리가 있다 )
3. 성능 최적화를 고려하고 만들어진 라이브러리가 아니다. 
출처 : https://www.samsungsds.com/kr/insights/jQuery.html


















