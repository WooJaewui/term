
 정리.



 # 저널링 파일 시스템 Jernaling File System.

저널링 파일 시스템.
- 일정 부분을 기록을 위해 남겨두어 백업 및 복구 능력이 있는 파일 시스템.

저널링 파일 시스템 동작 원리.
- 사용자가 어떤 내용을 입력 또는 수정하면 그 내용을 바로 하드디스크에 기록하기 전에 관련 내용을 로그에 기록한다.
- 문제가 발생하여 비정상적인 종료가 발생되면 재부팅할 때 로그에 기록된 내용을 참고하여 복구하게 된다.

저널링 파일 시스템의 장점.
- 서버에서는 다양한 내용을 빈번하게 기록하고 수정하기 때문에 오류가 발생했을 때 복구할 수 있는 기능이 더욱 중요해졌다.

저널링 파일 시스템의 단점.
- 수많은 로깅 데이터가 발생한다. ( 필요한 부분에만 적용하자 )

저널링 파일 시스템 사용 부분.
- /var 디렉토리 : 메일 스풀링 및 데이터베이스의 저장공간, 로그 기록 등의 용도로 사용.

출처.
https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hymne&logNo=220976732039



 # 스왑 공간.

관련 용어.
- 파티션 : 하드디스크의 논리적 분할.

스왑 swap.
- 시스템에 메모리가 부족할 경우에 하드 디스크의 일부 공간을 활용하여 계속 작업을 도와주는 영역.
- 하드 디스크의 일부를 RAM처럼 사용할 수 있게 만드는 것.

스와핑 swapping.
- RAM이 부족할 때 우선 하드디스크 공간으로 이용하고, 메모리가 다시 여유가 생겨 사용 가능해지면 메모리로 옮겨오는 것.

스왑 공간 swap space.
- 리눅스에서 물리적 메모리( RAM )의 용량이 가득 차게될 경우 사용되는 여유 공간.
- 시스템이 처리하고 있는 데이터를 저장할 RAM이 충분하지 않을 때 데이터를 기록.
- 스왑 공간은 하드 드라이브 상에 위치하기 때문에 물리적 메모리에 접근하는 것보다 접근 속도가 훨씬 느리다.

스왑 방식.
- 스왑 파티션.
	- 별도의 파일 시스템 개입 없이 파티션 전체가 스왑으로 동작.
	- 성능 저하가 없지만, 전용 파티션을 확보하기 어렵다.
- 스왑 파일.
	- 파일 시스템 내에 파일을 생성하고, 이 파일을 스왑 영역으로 사용하는 방식.
	- 스왑 파일을 생성하기 위해 파일 시스템이라는 중간 단계가 필요.
	- 파티션의 경우 디스크에 연속된 공간에 위치하지만, 스왑 파일은 디스크에서 연속된 공간을 할당 받지 못할 수 있다.
	- 위에 이유들로 성능 저하가 발생할 수 있다.

스왑 장점.
- RAM이 가득 찼을 때 보조 공간 제공.
- RAM처럼 빠르진 않지만 하드보다 빠른 속도로 사용 가능.
- 더 많은 공간 사용.

스왑 단점.
- swap 파티션은 크기를 유동성 있게 조정할 수 없기 때문에 하드 디스크의 공간을 차지함.
- 상황에 따라 사용해야 함.

스왑 인/아웃
- 스왑 인 : 디스크에 있는 데이터를 메모리로 읽어들이는 것.
- 스왑 아웃 : 메모리에 있는 데이터를 디스크로 읽어들이는 것.

정리.
- 항상 성능을 좋게 해주는 것은 아니므로, 적절하게 활용하여 효율을 내도록 해야한다.

출처.
- http://coffeenix.net/doc/RH-DOCS/rhl-cg-ko-9/ch-swapspace.html
- https://kldp.org/node/21251
- https://nearhome.tistory.com/64
- http://egloos.zum.com/knyatom/v/1460724 ( IT 용어 )



 # 라이브러리.

서브루틴 Sub-Routine.
- 반복되어 사용하는 것을 메모리에 적재하여 여러번 사용할 수 있도록 하는 방법이다.

라이브러리 Library.
- 소프트웨어를 만들 때 쓰이는 클래스나 서브루틴들의 모임을 가리키는 말이다.
- 하나 이상의 서브루틴이나 함수들의 집합 파일이다.
- 미리 컴파일 되어 있어서 컴파일 시간도 단축된다.

라이브러리 사용 목적.
- 코드 재사용을 위해 조직화된 초창기 방법 중의 하나이다.
- 많은 다른 프로그램들에서 사용할 수 있도록 운영체계나 소프트웨어 개발 환경 제공자들에 의해 제공되는 경우가 많다.
- 범용적으로 사용도 가능하며 3차원 애니메이션 그래픽 등과 같이 특별한 용도의 함수로 설계될 수도 있다.
- 라이브러리들은 사용자 프로그램과 링크되어 실행이 가능한 완전한 프로그램을 이룬다.

동적 라이브러리. ( Dynamic Library )
- 리눅스 .a , .so / 윈도우 .lib , .dll
- 완성 프로그램을 실행할 때 포함시키는 동적 라이브러리. 
- DLL을 구현하고 컴파일하고 나면 Static Library와는 다르게 output file이 2개가 생성된다. ( .lib / .dll )
- 여기서 생성된 .lib 파일은 정적 라이브러리 .lib 파일과는 전혀 다르다.
- 정적 라이브러리의 .lib 파일은 라이브러리 전체 코드를 포함하는 바이너리이며, DLL의 .lib는 함수 정보을 가지는 정보 파일이다.
- 프로그램 시작할 때 같이 로딩되어 프로그램 종료 할 때 메모리에서 해제되는 방법을 암시적 링킹( Implicit Linking )이라 한다.
- DLL의 .lib 파일을 이용하여 링킹하는 것을 암시적 링킹( implicit linking )이라고 한다.
- 프로그램 실행 시 필요시만 외부 DLL 파일에서 함수를 참조한다.
- 프로그램의 .obj파일과 DLL의 .lib 파일을 함께 링킹하여 이 정보를 토대로 runtime에 DLL의 함수 코드를 참조.
- .lib는 링킹시 필요, .dll은 실행시 필요하다.

동적 라이브러리 장점.
- 메모리를 절약하고 스와핑을 줄인다.
- 프로그램이 한번 메모리에 올려진 것을 공유하므로 메모리 사용 공간이 정적 라이브러리에 비해 적다.
- 여러 프로세스가 메모리에 있는 하나의 DLL 복사본을 공유하여 하나의 DLL을 동시에 사용할 수 있다.
- DLL을 보다 쉽게 업그레이드 할 수 있다.
- DLL의 함수가 변경되어도 그 함수의 인수 및 반환 값이 변경되지 않았으면 그 함수를 사용하는 응용 프로그램은 링크/재컴파일 할 필요가 없다.

동적 라이브러리 단점.
- 외부 의존도가 생기기 때문에 이식성이 어렵다.
- 공유 라이브러리를 메모리에 올리려면 찾고 올리는데 시간이 걸리므로 성능 저하가 생긴다.

정적 라이브러리.
- 프로그램 빌드 시에 라이브러리가 제공하는 코드를 실행 파일에 넣는 방식의 라이브러리를 의미한다.
- 컴파일의 링킹 단계에서 실행 파일에 결합된다.
- 특정 기능의 라이브러리를 static하게 제작한다는 것은 컴파일의 link 단계에서 라이브러리를 실행 바이너리에 포함시킨다.
- 런타임 때 별도의 추가 작업 없이 독립적으로 라이브러리 함수들을 사용할 수 있다.
- 링커가 프로그램이 필요로 하는 부분을 라이브러리에서 찾아 실행파일에 바로 복사.

정적 라이브러리 장점.
- 완성된 애플리케이션을 안정적으로 사용할 수 있다.
- 컴파일시 필요한 라이브러리를 프로그램 내에 적재하기 때문에 이식성이 좋다.
- 런타임시 외부를 참조할 필요가 없기 때문에 속도에서 장점이 있다.

정적 라이브러리 단점.
- 같은 코드를 가진 여러 프로그램을 실행할 경우 코드가 중복이 되니 그만큼 메모리를 낭비하게 된다.
- 라이브러리 변경이 필요할 시, 변경된 라이브러리만 재배포하면 안되고 프로그램을 다시 재배포해야 한다.

출처.
- https://goodgid.github.io/Static-VS-Dynamic-Libray/
- https://velog.io/@du0928/%EA%B3%BC%EC%A0%9C-1.-JDK-JDR-JVM-Java-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC ( 자바 원리 )



 # 자바스크립트.

프로미스 상태 3가지.
- Pending 대기 : 비동기 처리 로직이 아직 완료되지 않은 상태.
- Fulfilled 이행 : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태.
- Rejected 실패 : 비동기 처리가 실패하거나 오류가 발생한 상태.

async & await.
- 비동기 처리 방식인 콜백 함수와 프로미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성할 수 있게 도와준다.
















